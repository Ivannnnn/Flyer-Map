<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Street Map</title>

    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: Arial, sans-serif;
      }

      #map {
        height: 100vh;
        width: 100%;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      #loading {
        position: absolute;
        top: 10px;
        right: 10px;
        background: white;
        padding: 10px 20px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        display: none;
      }

      .polygon-label {
        background: transparent;
        border: none;
        text-align: center;
        font-size: 18px;
        font-weight: bold;
        color: #2c5aa0;
        text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.8),
          -2px -2px 4px rgba(255, 255, 255, 0.8),
          2px -2px 4px rgba(255, 255, 255, 0.8),
          -2px 2px 4px rgba(255, 255, 255, 0.8);
        pointer-events: none;
      }

      /* Prevent selection artifacts */
      .leaflet-container {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      .leaflet-interactive {
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div id="loading">Loading streets...</div>

    <script src="./areas.js"></script>
    <script>
      // window.areas should be defined in another file

      // Initialize map
      const map = L.map("map").setView([51.367, 12.375], 15)

      // Add OpenStreetMap tiles
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "Â© OpenStreetMap contributors",
      }).addTo(map)

      // Store street data - now keyed by "areaName:streetName"
      let streetGroups = new Map() // Map area:street names to all their segments
      let highlightedStreets = new Set() // Set of highlighted area:street combinations
      let locationMarker = null // GPS location marker
      let locationCircle = null // GPS accuracy circle
      let locationWatchId = null // Watch ID for location tracking
      let polygonLayers = [] // Store all polygon layers
      let allPolygonsLayer = null // Layer group for all polygons

      // Local storage key
      const STORAGE_KEY = "highlightedStreets"

      // Load highlighted streets from local storage
      function loadHighlightedStreetsFromStorage() {
        try {
          const stored = localStorage.getItem(STORAGE_KEY)
          if (stored) {
            const streetsArray = JSON.parse(stored)
            return new Set(streetsArray)
          }
        } catch (error) {
          console.error("Error loading from local storage:", error)
        }
        return new Set()
      }

      // Save highlighted streets to local storage
      function saveHighlightedStreetsToStorage() {
        try {
          const streetsArray = Array.from(highlightedStreets)
          localStorage.setItem(STORAGE_KEY, JSON.stringify(streetsArray))
        } catch (error) {
          console.error("Error saving to local storage:", error)
        }
      }

      // Add all polygons to map
      function addPolygonsToMap() {
        // Create a layer group for all polygons
        allPolygonsLayer = L.layerGroup()

        // Colors for different polygons (cycle through if more polygons than colors)
        const colors = [
          "#3388ff",
          "#ff8833",
          "#33ff88",
          "#ff3388",
          "#8833ff",
          "#88ff33",
        ]

        window.areas.features.forEach((feature, index) => {
          const color = colors[index % colors.length]

          // Add polygon layer with more visible borders
          const polygonLayer = L.geoJSON(feature, {
            style: {
              fillColor: color,
              fillOpacity: 0.1,
              color: color,
              weight: 4, // Thicker borders for visibility
              opacity: 0.8,
            },
          })

          polygonLayer.addTo(allPolygonsLayer)
          polygonLayers.push(polygonLayer)

          // Calculate polygon center for label
          const bounds = polygonLayer.getBounds()
          const center = bounds.getCenter()

          // Add text label with the area name
          const areaName = feature.properties.name || `Area ${index + 1}`
          const textLabel = L.divIcon({
            className: "polygon-label",
            html: `<div>${areaName}</div>`,
            iconSize: [80, 20],
            iconAnchor: [40, 10],
          })

          L.marker(center, {
            icon: textLabel,
            interactive: false,
          }).addTo(allPolygonsLayer)
        })

        // Add all polygons to map
        allPolygonsLayer.addTo(map)

        // Fit map to show all polygons
        if (polygonLayers.length > 0) {
          const combinedBounds = L.latLngBounds([])
          polygonLayers.forEach((layer) => {
            combinedBounds.extend(layer.getBounds())
          })
          map.fitBounds(combinedBounds)
        }
      }

      // GPS Location tracking
      function startLocationTracking() {
        // Check if geolocation is available
        if (!navigator.geolocation) {
          console.log("Geolocation is not supported by your browser")
          return
        }

        // Use native geolocation API for better control
        locationWatchId = navigator.geolocation.watchPosition(
          function (position) {
            const lat = position.coords.latitude
            const lng = position.coords.longitude
            const accuracy = position.coords.accuracy

            // Remove existing location marker and circle
            if (locationMarker) {
              map.removeLayer(locationMarker)
            }
            if (locationCircle) {
              map.removeLayer(locationCircle)
            }

            // Add location marker
            locationMarker = L.marker([lat, lng], {
              icon: L.icon({
                iconUrl:
                  "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSI4IiBmaWxsPSIjNDA5NWZmIiBzdHJva2U9IndoaXRlIiBzdHJva2Utd2lkdGg9IjMiLz48L3N2Zz4=",
                iconSize: [24, 24],
                iconAnchor: [12, 12],
              }),
            }).addTo(map)

            // Add accuracy circle
            locationCircle = L.circle([lat, lng], {
              radius: accuracy,
              color: "#4095ff",
              fillColor: "#4095ff",
              fillOpacity: 0.1,
              weight: 2,
            }).addTo(map)
          },
          function (error) {
            console.log("Location error:", error.message)
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0,
          }
        )
      }

      // Helper function to clip line to polygon
      function clipLineToPolygon(line, polygon) {
        const coords = line.geometry.coordinates
        const segments = []
        let currentSegment = []

        for (let i = 0; i < coords.length; i++) {
          const point = turf.point(coords[i])
          const isInside = turf.booleanPointInPolygon(point, polygon)

          if (isInside) {
            // Point is inside
            if (currentSegment.length === 0 && i > 0) {
              // We're entering the polygon, find intersection
              const edge = turf.lineString([coords[i - 1], coords[i]])
              try {
                const intersections = turf.lineIntersect(edge, polygon)
                if (intersections.features.length > 0) {
                  currentSegment.push(
                    intersections.features[0].geometry.coordinates
                  )
                }
              } catch (e) {
                // Handle intersection error
              }
            }
            currentSegment.push(coords[i])
          } else {
            // Point is outside
            if (currentSegment.length > 0) {
              // We're exiting the polygon, find intersection
              const edge = turf.lineString([coords[i - 1], coords[i]])
              try {
                const intersections = turf.lineIntersect(edge, polygon)
                if (intersections.features.length > 0) {
                  currentSegment.push(
                    intersections.features[0].geometry.coordinates
                  )
                }
              } catch (e) {
                // Handle intersection error
              }
              // Save segment
              if (currentSegment.length >= 2) {
                segments.push([...currentSegment])
              }
              currentSegment = []
            }
          }
        }

        // Save any remaining segment
        if (currentSegment.length >= 2) {
          segments.push(currentSegment)
        }

        return segments
      }

      // Function to load streets from Overpass API
      async function loadStreets() {
        document.getElementById("loading").style.display = "block"

        // Get combined bounds of all polygons
        const combinedBounds = L.latLngBounds([])
        polygonLayers.forEach((layer) => {
          combinedBounds.extend(layer.getBounds())
        })

        const south = combinedBounds.getSouth()
        const west = combinedBounds.getWest()
        const north = combinedBounds.getNorth()
        const east = combinedBounds.getEast()

        // Overpass API query for streets
        const overpassQuery = `
                [out:json][timeout:25];
                (
                    way["highway"~"^(primary|secondary|tertiary|residential|living_street|pedestrian|unclassified|service|footway|path)$"]
                    (${south},${west},${north},${east});
                );
                out geom;
            `

        try {
          const response = await fetch(
            "https://overpass-api.de/api/interpreter",
            {
              method: "POST",
              body: overpassQuery,
            }
          )

          const data = await response.json()

          // Clear existing street layers
          clearStreets()

          // Process street data
          processStreetData(data.elements)

          // Restore highlighted streets from local storage
          restoreHighlightedStreets()
        } catch (error) {
          console.error("Error loading streets:", error)
          alert("Error loading street data. Please try again.")
        } finally {
          document.getElementById("loading").style.display = "none"
        }
      }

      // Process street data and add to map
      function processStreetData(streets) {
        streets.forEach((street) => {
          if (street.geometry) {
            // Convert OSM geometry to coordinates
            const coordinates = street.geometry.map((node) => [
              node.lon,
              node.lat,
            ])

            // Create line string
            const line = turf.lineString(coordinates)

            // Check each polygon and clip the line
            window.areas.features.forEach((polygonFeature) => {
              const polygon = turf.polygon(polygonFeature.geometry.coordinates)
              const areaName = polygonFeature.properties.name

              try {
                // Clip the line to only show parts inside this polygon
                const clippedSegments = clipLineToPolygon(line, polygon)

                // Add each clipped segment to the map with area context
                clippedSegments.forEach((segmentCoords) => {
                  const segmentLine = turf.lineString(segmentCoords)
                  addStreetToMap(segmentLine, street, areaName)
                })
              } catch (error) {
                console.error("Error processing street:", error)
              }
            })
          }
        })
      }

      // Add street to map with click functionality
      function addStreetToMap(lineGeoJSON, streetData, areaName) {
        const streetName = streetData.tags?.name
        const isNamed = !!streetName

        // Create the Leaflet layer with thicker lines
        const streetLayer = L.geoJSON(lineGeoJSON, {
          style: {
            color: isNamed ? "#666" : "#999",
            weight: isNamed ? 5 : 3,
            opacity: isNamed ? 0.6 : 0.4,
          },
        })

        // Add to map
        streetLayer.addTo(map)

        // If street is named, make it interactive
        if (isNamed) {
          // Create a unique key for this street in this area
          const streetKey = `${areaName}:${streetName}`

          // Store this segment in the street groups with area context
          if (!streetGroups.has(streetKey)) {
            streetGroups.set(streetKey, [])
          }
          streetGroups.get(streetKey).push(streetLayer)

          // Add click handler to each sub-layer
          streetLayer.eachLayer(function (layer) {
            layer.on("click", function (e) {
              toggleStreet(streetKey)
              L.DomEvent.stopPropagation(e)
              L.DomEvent.preventDefault(e)
            })

            // Add hover effect
            layer.on("mouseover", function (e) {
              if (!highlightedStreets.has(streetKey)) {
                // Only highlight segments in this area
                const segments = streetGroups.get(streetKey)
                if (segments) {
                  segments.forEach((segment) => {
                    segment.setStyle({
                      color: "#333",
                      weight: 7,
                      opacity: 0.8,
                    })
                  })
                }
              }
            })

            layer.on("mouseout", function (e) {
              if (!highlightedStreets.has(streetKey)) {
                // Reset segments in this area
                const segments = streetGroups.get(streetKey)
                if (segments) {
                  segments.forEach((segment) => {
                    segment.setStyle({
                      color: "#666",
                      weight: 5,
                      opacity: 0.6,
                    })
                  })
                }
              }
            })

            // Add tooltip showing both street and area
            layer.bindTooltip(`${streetName} (${areaName})`, {
              permanent: false,
              direction: "top",
            })
          })
        }
      }

      // Toggle street highlight (only for specific area)
      function toggleStreet(streetKey) {
        const segments = streetGroups.get(streetKey)
        if (!segments) return

        if (highlightedStreets.has(streetKey)) {
          // Remove highlight
          highlightedStreets.delete(streetKey)
          segments.forEach((segment) => {
            segment.setStyle({
              color: "#666",
              weight: 5,
              opacity: 0.6,
            })
          })
        } else {
          // Add highlight - turn red
          highlightedStreets.add(streetKey)
          segments.forEach((segment) => {
            segment.setStyle({
              color: "#FF0000",
              weight: 8,
              opacity: 1,
            })
            segment.bringToFront()
          })
        }

        // Save to local storage
        saveHighlightedStreetsToStorage()
      }

      // Restore highlighted streets from local storage
      function restoreHighlightedStreets() {
        const savedStreets = loadHighlightedStreetsFromStorage()

        savedStreets.forEach((streetKey) => {
          const segments = streetGroups.get(streetKey)
          if (segments) {
            highlightedStreets.add(streetKey)
            segments.forEach((segment) => {
              segment.setStyle({
                color: "#FF0000",
                weight: 8,
                opacity: 1,
              })
              segment.bringToFront()
            })
          }
        })
      }

      // Clear all street layers
      function clearStreets() {
        streetGroups.forEach((segments, streetKey) => {
          segments.forEach((segment) => {
            map.removeLayer(segment)
          })
        })
        streetGroups.clear()
        // Don't clear highlightedStreets here - we want to preserve them
      }

      // Auto-load on page load
      window.addEventListener("load", () => {
        // Check if window.areas exists
        if (!window.areas || !window.areas.features) {
          console.error(
            "window.areas is not defined. Please make sure to load your areas data."
          )
          return
        }

        // Add polygons to map
        addPolygonsToMap()

        // Load streets after a short delay
        setTimeout(loadStreets, 1000)

        // Start location tracking
        setTimeout(startLocationTracking, 500)
      })
    </script>
  </body>
</html>
